// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package entities

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Wallet is an object representing the database table.
type Wallet struct {
	WalletID        uint64      `boil:"wallet_id" json:"wallet_id" toml:"wallet_id" yaml:"wallet_id"`
	CurrencyID      uint8       `boil:"currency_id" json:"currency_id" toml:"currency_id" yaml:"currency_id"`
	UserID          uint        `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	Balance         int64       `boil:"balance" json:"balance" toml:"balance" yaml:"balance"`
	WalletType      uint8       `boil:"wallet_type" json:"wallet_type" toml:"wallet_type" yaml:"wallet_type"`
	ExternalOwnerID null.Uint   `boil:"external_owner_id" json:"external_owner_id,omitempty" toml:"external_owner_id" yaml:"external_owner_id,omitempty"`
	Status          uint8       `boil:"status" json:"status" toml:"status" yaml:"status"`
	ParentWallet    null.Uint64 `boil:"parent_wallet" json:"parent_wallet,omitempty" toml:"parent_wallet" yaml:"parent_wallet,omitempty"`
	ParentMode      null.Uint8  `boil:"parent_mode" json:"parent_mode,omitempty" toml:"parent_mode" yaml:"parent_mode,omitempty"`
	Passphrase      null.Bytes  `boil:"passphrase" json:"passphrase,omitempty" toml:"passphrase" yaml:"passphrase,omitempty"`
	SpendLimit      uint64      `boil:"spend_limit" json:"spend_limit" toml:"spend_limit" yaml:"spend_limit"`
	TransferLimit   uint64      `boil:"transfer_limit" json:"transfer_limit" toml:"transfer_limit" yaml:"transfer_limit"`
	DepositLimit    uint64      `boil:"deposit_limit" json:"deposit_limit" toml:"deposit_limit" yaml:"deposit_limit"`
	WithdrawalLimit uint64      `boil:"withdrawal_limit" json:"withdrawal_limit" toml:"withdrawal_limit" yaml:"withdrawal_limit"`
	EditedAt        null.Time   `boil:"edited_at" json:"edited_at,omitempty" toml:"edited_at" yaml:"edited_at,omitempty"`
	CreatedAt       time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`

	R *walletR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L walletL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var WalletColumns = struct {
	WalletID        string
	CurrencyID      string
	UserID          string
	Balance         string
	WalletType      string
	ExternalOwnerID string
	Status          string
	ParentWallet    string
	ParentMode      string
	Passphrase      string
	SpendLimit      string
	TransferLimit   string
	DepositLimit    string
	WithdrawalLimit string
	EditedAt        string
	CreatedAt       string
}{
	WalletID:        "wallet_id",
	CurrencyID:      "currency_id",
	UserID:          "user_id",
	Balance:         "balance",
	WalletType:      "wallet_type",
	ExternalOwnerID: "external_owner_id",
	Status:          "status",
	ParentWallet:    "parent_wallet",
	ParentMode:      "parent_mode",
	Passphrase:      "passphrase",
	SpendLimit:      "spend_limit",
	TransferLimit:   "transfer_limit",
	DepositLimit:    "deposit_limit",
	WithdrawalLimit: "withdrawal_limit",
	EditedAt:        "edited_at",
	CreatedAt:       "created_at",
}

var WalletTableColumns = struct {
	WalletID        string
	CurrencyID      string
	UserID          string
	Balance         string
	WalletType      string
	ExternalOwnerID string
	Status          string
	ParentWallet    string
	ParentMode      string
	Passphrase      string
	SpendLimit      string
	TransferLimit   string
	DepositLimit    string
	WithdrawalLimit string
	EditedAt        string
	CreatedAt       string
}{
	WalletID:        "wallets.wallet_id",
	CurrencyID:      "wallets.currency_id",
	UserID:          "wallets.user_id",
	Balance:         "wallets.balance",
	WalletType:      "wallets.wallet_type",
	ExternalOwnerID: "wallets.external_owner_id",
	Status:          "wallets.status",
	ParentWallet:    "wallets.parent_wallet",
	ParentMode:      "wallets.parent_mode",
	Passphrase:      "wallets.passphrase",
	SpendLimit:      "wallets.spend_limit",
	TransferLimit:   "wallets.transfer_limit",
	DepositLimit:    "wallets.deposit_limit",
	WithdrawalLimit: "wallets.withdrawal_limit",
	EditedAt:        "wallets.edited_at",
	CreatedAt:       "wallets.created_at",
}

// Generated where

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Uint64 struct{ field string }

func (w whereHelpernull_Uint64) EQ(x null.Uint64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Uint64) NEQ(x null.Uint64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Uint64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Uint64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Uint64) LT(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Uint64) LTE(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Uint64) GT(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Uint64) GTE(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Bytes struct{ field string }

func (w whereHelpernull_Bytes) EQ(x null.Bytes) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bytes) NEQ(x null.Bytes) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bytes) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bytes) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Bytes) LT(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bytes) LTE(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bytes) GT(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bytes) GTE(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var WalletWhere = struct {
	WalletID        whereHelperuint64
	CurrencyID      whereHelperuint8
	UserID          whereHelperuint
	Balance         whereHelperint64
	WalletType      whereHelperuint8
	ExternalOwnerID whereHelpernull_Uint
	Status          whereHelperuint8
	ParentWallet    whereHelpernull_Uint64
	ParentMode      whereHelpernull_Uint8
	Passphrase      whereHelpernull_Bytes
	SpendLimit      whereHelperuint64
	TransferLimit   whereHelperuint64
	DepositLimit    whereHelperuint64
	WithdrawalLimit whereHelperuint64
	EditedAt        whereHelpernull_Time
	CreatedAt       whereHelpertime_Time
}{
	WalletID:        whereHelperuint64{field: "`wallets`.`wallet_id`"},
	CurrencyID:      whereHelperuint8{field: "`wallets`.`currency_id`"},
	UserID:          whereHelperuint{field: "`wallets`.`user_id`"},
	Balance:         whereHelperint64{field: "`wallets`.`balance`"},
	WalletType:      whereHelperuint8{field: "`wallets`.`wallet_type`"},
	ExternalOwnerID: whereHelpernull_Uint{field: "`wallets`.`external_owner_id`"},
	Status:          whereHelperuint8{field: "`wallets`.`status`"},
	ParentWallet:    whereHelpernull_Uint64{field: "`wallets`.`parent_wallet`"},
	ParentMode:      whereHelpernull_Uint8{field: "`wallets`.`parent_mode`"},
	Passphrase:      whereHelpernull_Bytes{field: "`wallets`.`passphrase`"},
	SpendLimit:      whereHelperuint64{field: "`wallets`.`spend_limit`"},
	TransferLimit:   whereHelperuint64{field: "`wallets`.`transfer_limit`"},
	DepositLimit:    whereHelperuint64{field: "`wallets`.`deposit_limit`"},
	WithdrawalLimit: whereHelperuint64{field: "`wallets`.`withdrawal_limit`"},
	EditedAt:        whereHelpernull_Time{field: "`wallets`.`edited_at`"},
	CreatedAt:       whereHelpertime_Time{field: "`wallets`.`created_at`"},
}

// WalletRels is where relationship names are stored.
var WalletRels = struct {
	ParentWalletWallet  string
	User                string
	Payments            string
	ParentWalletWallets string
}{
	ParentWalletWallet:  "ParentWalletWallet",
	User:                "User",
	Payments:            "Payments",
	ParentWalletWallets: "ParentWalletWallets",
}

// walletR is where relationships are stored.
type walletR struct {
	ParentWalletWallet  *Wallet      `boil:"ParentWalletWallet" json:"ParentWalletWallet" toml:"ParentWalletWallet" yaml:"ParentWalletWallet"`
	User                *User        `boil:"User" json:"User" toml:"User" yaml:"User"`
	Payments            PaymentSlice `boil:"Payments" json:"Payments" toml:"Payments" yaml:"Payments"`
	ParentWalletWallets WalletSlice  `boil:"ParentWalletWallets" json:"ParentWalletWallets" toml:"ParentWalletWallets" yaml:"ParentWalletWallets"`
}

// NewStruct creates a new relationship struct
func (*walletR) NewStruct() *walletR {
	return &walletR{}
}

// walletL is where Load methods for each relationship are stored.
type walletL struct{}

var (
	walletAllColumns            = []string{"wallet_id", "currency_id", "user_id", "balance", "wallet_type", "external_owner_id", "status", "parent_wallet", "parent_mode", "passphrase", "spend_limit", "transfer_limit", "deposit_limit", "withdrawal_limit", "edited_at", "created_at"}
	walletColumnsWithoutDefault = []string{"currency_id", "user_id", "balance", "parent_wallet", "parent_mode", "passphrase", "edited_at"}
	walletColumnsWithDefault    = []string{"wallet_id", "wallet_type", "external_owner_id", "status", "spend_limit", "transfer_limit", "deposit_limit", "withdrawal_limit", "created_at"}
	walletPrimaryKeyColumns     = []string{"wallet_id"}
)

type (
	// WalletSlice is an alias for a slice of pointers to Wallet.
	// This should almost always be used instead of []Wallet.
	WalletSlice []*Wallet
	// WalletHook is the signature for custom Wallet hook methods
	WalletHook func(context.Context, boil.ContextExecutor, *Wallet) error

	walletQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	walletType                 = reflect.TypeOf(&Wallet{})
	walletMapping              = queries.MakeStructMapping(walletType)
	walletPrimaryKeyMapping, _ = queries.BindMapping(walletType, walletMapping, walletPrimaryKeyColumns)
	walletInsertCacheMut       sync.RWMutex
	walletInsertCache          = make(map[string]insertCache)
	walletUpdateCacheMut       sync.RWMutex
	walletUpdateCache          = make(map[string]updateCache)
	walletUpsertCacheMut       sync.RWMutex
	walletUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var walletBeforeInsertHooks []WalletHook
var walletBeforeUpdateHooks []WalletHook
var walletBeforeDeleteHooks []WalletHook
var walletBeforeUpsertHooks []WalletHook

var walletAfterInsertHooks []WalletHook
var walletAfterSelectHooks []WalletHook
var walletAfterUpdateHooks []WalletHook
var walletAfterDeleteHooks []WalletHook
var walletAfterUpsertHooks []WalletHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Wallet) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Wallet) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Wallet) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Wallet) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Wallet) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Wallet) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Wallet) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Wallet) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Wallet) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range walletAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddWalletHook registers your hook function for all future operations.
func AddWalletHook(hookPoint boil.HookPoint, walletHook WalletHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		walletBeforeInsertHooks = append(walletBeforeInsertHooks, walletHook)
	case boil.BeforeUpdateHook:
		walletBeforeUpdateHooks = append(walletBeforeUpdateHooks, walletHook)
	case boil.BeforeDeleteHook:
		walletBeforeDeleteHooks = append(walletBeforeDeleteHooks, walletHook)
	case boil.BeforeUpsertHook:
		walletBeforeUpsertHooks = append(walletBeforeUpsertHooks, walletHook)
	case boil.AfterInsertHook:
		walletAfterInsertHooks = append(walletAfterInsertHooks, walletHook)
	case boil.AfterSelectHook:
		walletAfterSelectHooks = append(walletAfterSelectHooks, walletHook)
	case boil.AfterUpdateHook:
		walletAfterUpdateHooks = append(walletAfterUpdateHooks, walletHook)
	case boil.AfterDeleteHook:
		walletAfterDeleteHooks = append(walletAfterDeleteHooks, walletHook)
	case boil.AfterUpsertHook:
		walletAfterUpsertHooks = append(walletAfterUpsertHooks, walletHook)
	}
}

// One returns a single wallet record from the query.
func (q walletQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Wallet, error) {
	o := &Wallet{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "entities: failed to execute a one query for wallets")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Wallet records from the query.
func (q walletQuery) All(ctx context.Context, exec boil.ContextExecutor) (WalletSlice, error) {
	var o []*Wallet

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "entities: failed to assign all query results to Wallet slice")
	}

	if len(walletAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Wallet records in the query.
func (q walletQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "entities: failed to count wallets rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q walletQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "entities: failed to check if wallets exists")
	}

	return count > 0, nil
}

// ParentWalletWallet pointed to by the foreign key.
func (o *Wallet) ParentWalletWallet(mods ...qm.QueryMod) walletQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`wallet_id` = ?", o.ParentWallet),
	}

	queryMods = append(queryMods, mods...)

	query := Wallets(queryMods...)
	queries.SetFrom(query.Query, "`wallets`")

	return query
}

// User pointed to by the foreign key.
func (o *Wallet) User(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`user_id` = ?", o.UserID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "`users`")

	return query
}

// Payments retrieves all the payment's Payments with an executor.
func (o *Wallet) Payments(mods ...qm.QueryMod) paymentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`payments`.`wallet_id`=?", o.WalletID),
	)

	query := Payments(queryMods...)
	queries.SetFrom(query.Query, "`payments`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`payments`.*"})
	}

	return query
}

// ParentWalletWallets retrieves all the wallet's Wallets with an executor via parent_wallet column.
func (o *Wallet) ParentWalletWallets(mods ...qm.QueryMod) walletQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`wallets`.`parent_wallet`=?", o.WalletID),
	)

	query := Wallets(queryMods...)
	queries.SetFrom(query.Query, "`wallets`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`wallets`.*"})
	}

	return query
}

// LoadParentWalletWallet allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (walletL) LoadParentWalletWallet(ctx context.Context, e boil.ContextExecutor, singular bool, maybeWallet interface{}, mods queries.Applicator) error {
	var slice []*Wallet
	var object *Wallet

	if singular {
		object = maybeWallet.(*Wallet)
	} else {
		slice = *maybeWallet.(*[]*Wallet)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &walletR{}
		}
		if !queries.IsNil(object.ParentWallet) {
			args = append(args, object.ParentWallet)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &walletR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ParentWallet) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ParentWallet) {
				args = append(args, obj.ParentWallet)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`wallets`),
		qm.WhereIn(`wallets.wallet_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Wallet")
	}

	var resultSlice []*Wallet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Wallet")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for wallets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wallets")
	}

	if len(walletAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ParentWalletWallet = foreign
		if foreign.R == nil {
			foreign.R = &walletR{}
		}
		foreign.R.ParentWalletWallets = append(foreign.R.ParentWalletWallets, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ParentWallet, foreign.WalletID) {
				local.R.ParentWalletWallet = foreign
				if foreign.R == nil {
					foreign.R = &walletR{}
				}
				foreign.R.ParentWalletWallets = append(foreign.R.ParentWalletWallets, local)
				break
			}
		}
	}

	return nil
}

// LoadUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (walletL) LoadUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeWallet interface{}, mods queries.Applicator) error {
	var slice []*Wallet
	var object *Wallet

	if singular {
		object = maybeWallet.(*Wallet)
	} else {
		slice = *maybeWallet.(*[]*Wallet)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &walletR{}
		}
		args = append(args, object.UserID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &walletR{}
			}

			for _, a := range args {
				if a == obj.UserID {
					continue Outer
				}
			}

			args = append(args, obj.UserID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(walletAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.User = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.Wallets = append(foreign.R.Wallets, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.UserID == foreign.UserID {
				local.R.User = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.Wallets = append(foreign.R.Wallets, local)
				break
			}
		}
	}

	return nil
}

// LoadPayments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (walletL) LoadPayments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeWallet interface{}, mods queries.Applicator) error {
	var slice []*Wallet
	var object *Wallet

	if singular {
		object = maybeWallet.(*Wallet)
	} else {
		slice = *maybeWallet.(*[]*Wallet)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &walletR{}
		}
		args = append(args, object.WalletID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &walletR{}
			}

			for _, a := range args {
				if a == obj.WalletID {
					continue Outer
				}
			}

			args = append(args, obj.WalletID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`payments`),
		qm.WhereIn(`payments.wallet_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load payments")
	}

	var resultSlice []*Payment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice payments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on payments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payments")
	}

	if len(paymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Payments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentR{}
			}
			foreign.R.Wallet = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.WalletID == foreign.WalletID {
				local.R.Payments = append(local.R.Payments, foreign)
				if foreign.R == nil {
					foreign.R = &paymentR{}
				}
				foreign.R.Wallet = local
				break
			}
		}
	}

	return nil
}

// LoadParentWalletWallets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (walletL) LoadParentWalletWallets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeWallet interface{}, mods queries.Applicator) error {
	var slice []*Wallet
	var object *Wallet

	if singular {
		object = maybeWallet.(*Wallet)
	} else {
		slice = *maybeWallet.(*[]*Wallet)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &walletR{}
		}
		args = append(args, object.WalletID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &walletR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.WalletID) {
					continue Outer
				}
			}

			args = append(args, obj.WalletID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`wallets`),
		qm.WhereIn(`wallets.parent_wallet in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load wallets")
	}

	var resultSlice []*Wallet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice wallets")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on wallets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wallets")
	}

	if len(walletAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ParentWalletWallets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &walletR{}
			}
			foreign.R.ParentWalletWallet = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.WalletID, foreign.ParentWallet) {
				local.R.ParentWalletWallets = append(local.R.ParentWalletWallets, foreign)
				if foreign.R == nil {
					foreign.R = &walletR{}
				}
				foreign.R.ParentWalletWallet = local
				break
			}
		}
	}

	return nil
}

// SetParentWalletWallet of the wallet to the related item.
// Sets o.R.ParentWalletWallet to related.
// Adds o to related.R.ParentWalletWallets.
func (o *Wallet) SetParentWalletWallet(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Wallet) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `wallets` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"parent_wallet"}),
		strmangle.WhereClause("`", "`", 0, walletPrimaryKeyColumns),
	)
	values := []interface{}{related.WalletID, o.WalletID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ParentWallet, related.WalletID)
	if o.R == nil {
		o.R = &walletR{
			ParentWalletWallet: related,
		}
	} else {
		o.R.ParentWalletWallet = related
	}

	if related.R == nil {
		related.R = &walletR{
			ParentWalletWallets: WalletSlice{o},
		}
	} else {
		related.R.ParentWalletWallets = append(related.R.ParentWalletWallets, o)
	}

	return nil
}

// RemoveParentWalletWallet relationship.
// Sets o.R.ParentWalletWallet to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Wallet) RemoveParentWalletWallet(ctx context.Context, exec boil.ContextExecutor, related *Wallet) error {
	var err error

	queries.SetScanner(&o.ParentWallet, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("parent_wallet")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ParentWalletWallet = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ParentWalletWallets {
		if queries.Equal(o.ParentWallet, ri.ParentWallet) {
			continue
		}

		ln := len(related.R.ParentWalletWallets)
		if ln > 1 && i < ln-1 {
			related.R.ParentWalletWallets[i] = related.R.ParentWalletWallets[ln-1]
		}
		related.R.ParentWalletWallets = related.R.ParentWalletWallets[:ln-1]
		break
	}
	return nil
}

// SetUser of the wallet to the related item.
// Sets o.R.User to related.
// Adds o to related.R.Wallets.
func (o *Wallet) SetUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `wallets` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
		strmangle.WhereClause("`", "`", 0, walletPrimaryKeyColumns),
	)
	values := []interface{}{related.UserID, o.WalletID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.UserID = related.UserID
	if o.R == nil {
		o.R = &walletR{
			User: related,
		}
	} else {
		o.R.User = related
	}

	if related.R == nil {
		related.R = &userR{
			Wallets: WalletSlice{o},
		}
	} else {
		related.R.Wallets = append(related.R.Wallets, o)
	}

	return nil
}

// AddPayments adds the given related objects to the existing relationships
// of the wallet, optionally inserting them as new records.
// Appends related to o.R.Payments.
// Sets related.R.Wallet appropriately.
func (o *Wallet) AddPayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Payment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.WalletID = o.WalletID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `payments` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"wallet_id"}),
				strmangle.WhereClause("`", "`", 0, paymentPrimaryKeyColumns),
			)
			values := []interface{}{o.WalletID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.WalletID = o.WalletID
		}
	}

	if o.R == nil {
		o.R = &walletR{
			Payments: related,
		}
	} else {
		o.R.Payments = append(o.R.Payments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentR{
				Wallet: o,
			}
		} else {
			rel.R.Wallet = o
		}
	}
	return nil
}

// AddParentWalletWallets adds the given related objects to the existing relationships
// of the wallet, optionally inserting them as new records.
// Appends related to o.R.ParentWalletWallets.
// Sets related.R.ParentWalletWallet appropriately.
func (o *Wallet) AddParentWalletWallets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Wallet) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ParentWallet, o.WalletID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `wallets` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"parent_wallet"}),
				strmangle.WhereClause("`", "`", 0, walletPrimaryKeyColumns),
			)
			values := []interface{}{o.WalletID, rel.WalletID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ParentWallet, o.WalletID)
		}
	}

	if o.R == nil {
		o.R = &walletR{
			ParentWalletWallets: related,
		}
	} else {
		o.R.ParentWalletWallets = append(o.R.ParentWalletWallets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &walletR{
				ParentWalletWallet: o,
			}
		} else {
			rel.R.ParentWalletWallet = o
		}
	}
	return nil
}

// SetParentWalletWallets removes all previously related items of the
// wallet replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ParentWalletWallet's ParentWalletWallets accordingly.
// Replaces o.R.ParentWalletWallets with related.
// Sets related.R.ParentWalletWallet's ParentWalletWallets accordingly.
func (o *Wallet) SetParentWalletWallets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Wallet) error {
	query := "update `wallets` set `parent_wallet` = null where `parent_wallet` = ?"
	values := []interface{}{o.WalletID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ParentWalletWallets {
			queries.SetScanner(&rel.ParentWallet, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ParentWalletWallet = nil
		}

		o.R.ParentWalletWallets = nil
	}
	return o.AddParentWalletWallets(ctx, exec, insert, related...)
}

// RemoveParentWalletWallets relationships from objects passed in.
// Removes related items from R.ParentWalletWallets (uses pointer comparison, removal does not keep order)
// Sets related.R.ParentWalletWallet.
func (o *Wallet) RemoveParentWalletWallets(ctx context.Context, exec boil.ContextExecutor, related ...*Wallet) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ParentWallet, nil)
		if rel.R != nil {
			rel.R.ParentWalletWallet = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("parent_wallet")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ParentWalletWallets {
			if rel != ri {
				continue
			}

			ln := len(o.R.ParentWalletWallets)
			if ln > 1 && i < ln-1 {
				o.R.ParentWalletWallets[i] = o.R.ParentWalletWallets[ln-1]
			}
			o.R.ParentWalletWallets = o.R.ParentWalletWallets[:ln-1]
			break
		}
	}

	return nil
}

// Wallets retrieves all the records using an executor.
func Wallets(mods ...qm.QueryMod) walletQuery {
	mods = append(mods, qm.From("`wallets`"))
	return walletQuery{NewQuery(mods...)}
}

// FindWallet retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindWallet(ctx context.Context, exec boil.ContextExecutor, walletID uint64, selectCols ...string) (*Wallet, error) {
	walletObj := &Wallet{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `wallets` where `wallet_id`=?", sel,
	)

	q := queries.Raw(query, walletID)

	err := q.Bind(ctx, exec, walletObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "entities: unable to select from wallets")
	}

	if err = walletObj.doAfterSelectHooks(ctx, exec); err != nil {
		return walletObj, err
	}

	return walletObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Wallet) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("entities: no wallets provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(walletColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	walletInsertCacheMut.RLock()
	cache, cached := walletInsertCache[key]
	walletInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			walletAllColumns,
			walletColumnsWithDefault,
			walletColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(walletType, walletMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(walletType, walletMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `wallets` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `wallets` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `wallets` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, walletPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "entities: unable to insert into wallets")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.WalletID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == walletMapping["wallet_id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.WalletID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "entities: unable to populate default values for wallets")
	}

CacheNoHooks:
	if !cached {
		walletInsertCacheMut.Lock()
		walletInsertCache[key] = cache
		walletInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Wallet.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Wallet) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	walletUpdateCacheMut.RLock()
	cache, cached := walletUpdateCache[key]
	walletUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			walletAllColumns,
			walletPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("entities: unable to update wallets, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `wallets` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, walletPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(walletType, walletMapping, append(wl, walletPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to update wallets row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entities: failed to get rows affected by update for wallets")
	}

	if !cached {
		walletUpdateCacheMut.Lock()
		walletUpdateCache[key] = cache
		walletUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q walletQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to update all for wallets")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to retrieve rows affected for wallets")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o WalletSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("entities: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), walletPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `wallets` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, walletPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to update all in wallet slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to retrieve rows affected all in update all wallet")
	}
	return rowsAff, nil
}

var mySQLWalletUniqueColumns = []string{
	"wallet_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Wallet) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("entities: no wallets provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(walletColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLWalletUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	walletUpsertCacheMut.RLock()
	cache, cached := walletUpsertCache[key]
	walletUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			walletAllColumns,
			walletColumnsWithDefault,
			walletColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			walletAllColumns,
			walletPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("entities: unable to upsert wallets, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`wallets`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `wallets` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(walletType, walletMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(walletType, walletMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "entities: unable to upsert for wallets")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.WalletID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == walletMapping["wallet_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(walletType, walletMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "entities: unable to retrieve unique values for wallets")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "entities: unable to populate default values for wallets")
	}

CacheNoHooks:
	if !cached {
		walletUpsertCacheMut.Lock()
		walletUpsertCache[key] = cache
		walletUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Wallet record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Wallet) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("entities: no Wallet provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), walletPrimaryKeyMapping)
	sql := "DELETE FROM `wallets` WHERE `wallet_id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to delete from wallets")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entities: failed to get rows affected by delete for wallets")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q walletQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("entities: no walletQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to delete all from wallets")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entities: failed to get rows affected by deleteall for wallets")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o WalletSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(walletBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), walletPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `wallets` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, walletPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "entities: unable to delete all from wallet slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entities: failed to get rows affected by deleteall for wallets")
	}

	if len(walletAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Wallet) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindWallet(ctx, exec, o.WalletID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *WalletSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := WalletSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), walletPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `wallets`.* FROM `wallets` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, walletPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "entities: unable to reload all in WalletSlice")
	}

	*o = slice

	return nil
}

// WalletExists checks if the Wallet row exists.
func WalletExists(ctx context.Context, exec boil.ContextExecutor, walletID uint64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `wallets` where `wallet_id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, walletID)
	}
	row := exec.QueryRowContext(ctx, sql, walletID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "entities: unable to check if wallets exists")
	}

	return exists, nil
}
